{% extends "data_collection/templates/base.html" %}
{% load static %}

{% block content %}
<div class="row">
  <div class="col-lg-12">
    <div class="d-flex justify-content-between align-items-center mb-4">
      <h2 class="mb-0">
        <i data-lucide="map-pin" class="me-2" size="24"></i>
        Add Farm for {{ farmer.first_name }} {{ farmer.last_name }}
      </h2>
    </div>
    
    <!-- Alert Messages -->
    <div id="messageContainer">
      <div class="alert alert-success form-alert" id="successAlert" role="alert" style="display:none;">
        <i data-lucide="check-circle" size="18" class="me-2"></i>
        <span id="successMessage"></span>
      </div>
      <div class="alert alert-danger form-alert" id="errorAlert" role="alert" style="display:none;">
        <i data-lucide="alert-circle" size="18" class="me-2"></i>
        <span id="errorMessage"></span>
      </div>
    </div>
  </div>
</div>

<div class="row">
  <!-- Existing Farms Section -->
  <div class="col-lg-4 mb-4">
    <div class="card">
      <div class="card-header bg-light">
        <div class="d-flex justify-content-between align-items-center">
          <h5 class="mb-0">
            <i data-lucide="list" size="18" class="me-2"></i>
            Existing Farms
          </h5>
          <span class="badge bg-primary" id="farmCount">0</span>
        </div>
      </div>
      <div class="card-body p-0">
        <div id="farmsList" class="p-3">
          <div class="d-flex justify-content-center py-4">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
          </div>
        </div>
        
        <!-- Empty State -->
        <div id="noFarmsMessage" class="text-center py-4" style="display:none;">
          <i data-lucide="info" size="40" class="text-muted mb-2"></i>
          <p class="text-muted">No farms added yet</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Add Farm Form Section -->
  <div class="col-lg-8">
    <div class="card">
      <div class="card-header bg-light">
        <h5 class="mb-0">
          <i data-lucide="plus-circle" size="18" class="me-2"></i>
          Farm Details
        </h5>
      </div>
      <div class="card-body">
        <form id="farmForm" method="post" enctype="multipart/form-data">
          {% csrf_token %}
          
          <div class="row">
            <div class="col-md-6 mb-3">
              <label for="id_farm_name" class="form-label">Farm Name</label>
              {{ form.farm_name }}
              <style>
                #id_farm_name {
                  width: 100%;
                  padding: 0.6rem 1rem;
                  border-radius: 6px;
                  border: 1px solid #ced4da;
                  transition: border-color 0.2s ease, box-shadow 0.2s ease;
                  display: block;
                  font-size: 1rem;
                  font-weight: 400;
                  line-height: 1.5;
                  color: #212529;
                  background-color: #fff;
                  background-clip: padding-box;
                  appearance: none;
                }
              </style>
            </div>
            
            <div class="col-md-6 mb-3">
              <label for="id_area_in_acres" class="form-label">Area (in acres)</label>
              {{ form.area_in_acres }}
              <small class="text-muted">This will be calculated based on boundary</small>
            </div>
          </div>
          
          <div class="mb-3">
            <label for="id_ownership" class="form-label">Ownership</label>
            {{ form.ownership }}
          </div>
          
          <!-- Leased Fields (Initially Hidden) -->
          <div id="leasedFields" style="display: none;">
            <div class="card mb-3 border-warning">
              <div class="card-body">
                <h6 class="card-title">
                  <i data-lucide="file-text" size="18" class="me-2"></i>
                  Lease Information
                </h6>
                
                <div class="row mt-3">
                  <div class="col-md-6 mb-3">
                    <label for="id_owner_full_name" class="form-label">Owner Full Name</label>
                    {{ form.owner_full_name }}
                  </div>
                  
                  <div class="col-md-6 mb-3">
                    <label for="id_owner_mobile_number" class="form-label">Owner Mobile Number</label>
                    {{ form.owner_mobile_number }}
                  </div>
                </div>
                
                <div class="mb-3">
                  <label for="landlordDeclaration" class="form-label">
                    <i data-lucide="file" size="16" class="me-1"></i>
                    Landlord Declaration
                  </label>
                  <input type="file" id="landlordDeclaration" name="landlord_declaration" 
                         accept="image/*" class="form-control" capture="environment">
                  <img id="landlordPreview" class="mt-2" alt="Declaration preview" 
                       style="max-width: 200px; max-height: 150px; border-radius: 4px; display: none;">
                  <small class="form-text text-muted">Upload a photo of the landlord declaration document</small>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Land Ownership Document -->
          <div class="mb-3">
            <label for="landOwnership" class="form-label">
              <i data-lucide="file-text" size="16" class="me-1"></i>
              Land Ownership Document
            </label>
            <input type="file" id="landOwnership" name="land_ownership" 
                   accept="image/*" class="form-control" capture="environment">
            <img id="ownershipPreview" class="mt-2" alt="Document preview"
                 style="max-width: 200px; max-height: 150px; border-radius: 4px; display: none;">
            <small class="form-text text-muted">Upload a photo of the ownership document</small>
          </div>
          
          <!-- Boundary Method -->
          <div class="mb-4">
            <label for="id_boundary_method" class="form-label">Boundary Method</label>
            {{ form.boundary_method }}
            <small class="form-text text-muted">Choose how you want to mark the farm boundary</small>
          </div>
          
          <input type="hidden" name="boundary" id="boundary">
          
          <!-- Map Container -->
          <div class="card mb-4">
            <div class="card-body p-0 position-relative">
              <div id="map" style="height: 400px; border-radius: 12px; margin-bottom: 0;"></div>
              <div class="position-absolute top-0 end-0 m-2" id="mapControls">
                <button type="button" class="btn btn-sm btn-light mb-2" id="clearMapBtn">
                  <i data-lucide="trash-2" size="16"></i> Clear
                </button>
                <button type="button" class="btn btn-sm btn-light" id="currentLocationBtn">
                  <i data-lucide="map-pin" size="16"></i> My Location
                </button>
              </div>
            </div>
            <div class="card-footer" id="mapInfo">
              <div style="background: #e9f7f2; border-radius: 6px; padding: 0.75rem; border-left: 3px solid var(--primary-color);">

              </div>
              <div class="text-muted small mt-2">
                <i data-lucide="info" size="16" class="me-1"></i>
                For manual boundary, click on the map to add points. 
              </div>
            </div>
          </div>
          
          <!-- Submit Buttons -->
          <div class="d-grid gap-2">
            <button type="submit" class="btn btn-success" id="submitAndGoNext">
              <i data-lucide="save" size="18" class="me-2"></i>
              Save Farm and Continue
            </button>
            <button type="submit" class="btn btn-primary" id="submitAndAddMore">
              <i data-lucide="plus" size="18" class="me-2"></i>
              Save Farm and Add Another
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>
</div>

<!-- Add form style for Django generated fields -->
<style>
  /* Basic styling for Django form elements */
  select, input[type="text"], input[type="number"], input[type="tel"], input[type="email"], textarea {
    width: 100%;
    padding: 0.6rem 1rem;
    border-radius: 6px;
    border: 1px solid #ced4da;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
    display: block;
    font-size: 1rem;
    font-weight: 400;
    line-height: 1.5;
    color: #212529;
    background-color: #fff;
    background-clip: padding-box;
    appearance: none;
  }
  
  select {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 16px 12px;
    padding-right: 2.5rem;
  }
  
  select:focus, input:focus, textarea:focus {
    border-color: var(--primary-light);
    box-shadow: 0 0 0 0.25rem rgba(41, 187, 137, 0.25);
    outline: 0;
  }
</style>

<!-- File Upload Preview Script -->
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Show/hide leased fields based on ownership selection
    const ownershipSelect = document.getElementById('id_ownership');
    const leasedFields = document.getElementById('leasedFields');
    
    ownershipSelect.addEventListener('change', function() {
      if (this.value === 'leased') {
        leasedFields.style.display = 'block';
      } else {
        leasedFields.style.display = 'none';
      }
    });
    
    // Initial check for ownership field
    if (ownershipSelect.value === 'leased') {
      leasedFields.style.display = 'block';
    }
    
    // Image preview for landlord declaration
    document.getElementById('landlordDeclaration').addEventListener('change', function(e) {
      const preview = document.getElementById('landlordPreview');
      if (this.files && this.files[0]) {
        const reader = new FileReader();
        reader.onload = function(e) {
          preview.src = e.target.result;
          preview.style.display = 'block';
        }
        reader.readAsDataURL(this.files[0]);
      }
    });
    
    // Image preview for ownership document
    document.getElementById('landOwnership').addEventListener('change', function(e) {
      const preview = document.getElementById('ownershipPreview');
      if (this.files && this.files[0]) {
        const reader = new FileReader();
        reader.onload = function(e) {
          preview.src = e.target.result;
          preview.style.display = 'block';
        }
        reader.readAsDataURL(this.files[0]);
      }
    });
    
    // Initialize Lucide icons for dynamically added elements
    if (typeof lucide !== 'undefined') {
      lucide.createIcons();
    }
  });
</script>

<!-- Leaflet & Leaflet Draw JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script>
    // Image compression function
    function compressImage(file, quality, maxWidth, callback) {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = function(event) {
            const img = new Image();
            img.src = event.target.result;
            img.onload = function() {
                let width = img.width;
                let height = img.height;
                if (width > maxWidth) {
                    height = (maxWidth / width) * height;
                    width = maxWidth;
                }
                
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                canvas.toBlob(function(blob) {
                    const compressedFile = new File([blob], file.name, {
                        type: 'image/jpeg',
                        lastModified: Date.now()
                    });
                    callback(compressedFile);
                }, 'image/jpeg', quality);
            };
        };
    }

    // Apply compression to all image inputs
    document.querySelectorAll('input[type="file"][accept*="image"]').forEach(input => {
        input.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            if (!file.type.startsWith('image/')) return;

            const label = this.previousElementSibling;
            const originalLabelText = label.textContent;
            label.textContent = `${originalLabelText} (Compressing...)`;

            compressImage(file, 0.6, 1280, (compressedFile) => {
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(compressedFile);
                this.files = dataTransfer.files;

                label.textContent = originalLabelText;
                console.log(`Compressed ${file.name} from ${Math.round(file.size/1024)}KB to ${Math.round(compressedFile.size/1024)}KB`);
            });
        });
    });
</script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        // Base map layers (unchanged)
        var streets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            maxZoom: 22
        });
    
        var satellite = L.tileLayer('/tiles/s/{z}/{x}/{y}', {
            attribution: '&copy; Google Satellite',
            maxZoom: 22
        });
        
        var terrain = L.tileLayer('/tiles/p/{z}/{x}/{y}', {
            attribution: '&copy; Google Terrain',
            maxZoom: 22
        });
        
        var hybrid = L.tileLayer('/tiles/y/{z}/{x}/{y}', {
            attribution: '&copy; Google Hybrid',
            maxZoom: 22
        });
    
        var esri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri World Imagery',
            maxZoom: 22
        });
    
        // Overlay for Place Names & Boundaries
        var esriLabels = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri, HERE, Garmin',
            maxZoom: 22
        });
        
        var esriClarity = L.tileLayer(
            'https://clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri, Maxar, Earthstar Geographics',
            maxZoom: 22
        });       
    
        // Map initialization
        var map = L.map('map', {
            center: [23.6157, 81.9195], 
            zoom: 6,
            maxZoom: 22,
            layers: hybrid
        });
    
        // Layer control to switch between different maps
        var baseMaps = {
            "Streets": streets,
            "Google Satellite": satellite,
            "Google Terrain": terrain,
            "Google Hybrid": hybrid,
            "Esri World Imagery": esri,
            "Esri Clarity": esriClarity
        };
    
        var overlayMaps = {
            "Place Names & Boundaries": esriLabels
        };
    
        L.control.layers(baseMaps, overlayMaps).addTo(map);
    
        // Feature group for existing farms
        var existingFarms = new L.FeatureGroup();
        map.addLayer(existingFarms);
    
        // Feature group for drawn items
        var drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
    
        // Get existing farms from API
        fetchExistingFarms();
    
        // Function to fetch existing farms
        function fetchExistingFarms() {
            fetch(`/api/farms/{{ farmer.id }}/`, {
                method: "GET",
                headers: { "X-Requested-With": "XMLHttpRequest" }
            })
            .then(response => response.json())
            .then(data => {
                // Clear existing farms
                existingFarms.clearLayers();
                
                // Display farms in the list
                let farmsListHtml = '';
                
                if (data.farms && data.farms.length > 0) {
                    farmsListHtml = '<ul class="list-group">';
                    
                    // Generate farm colors for consistency
                    const farmColors = {};
                    data.farms.forEach((farm, index) => {
                        // Generate colors based on index
                        const colors = ['#FF5733', '#33FF57', '#3357FF', '#F3FF33', '#FF33F3', '#33FFF3', '#FF8C33', '#8C33FF'];
                        farmColors[farm.id] = colors[index % colors.length];
                    });
                    
                    // Add farms to the list and map
                    data.farms.forEach(farm => {
                        const farmColor = farmColors[farm.id];
                        
                        // Add to HTML list
                        farmsListHtml += `
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <div>
                                    <span class="badge bg-secondary" style="background-color: ${farmColor} !important;">&nbsp;</span>
                                    ${farm.farm_name}
                                </div>
                                <button class="btn btn-sm btn-outline-primary zoom-to-farm" data-farm-id="${farm.id}">
                                    Zoom to Farm
                                </button>
                            </li>
                        `;
                        
                        // Add boundary to map
                        try {
                            const geoJsonFeature = JSON.parse(farm.boundary);
                            const layer = L.geoJSON(geoJsonFeature, {
                                style: {
                                    color: farmColor,
                                    fillColor: farmColor,
                                    fillOpacity: 0.3,
                                    weight: 2
                                }
                            });
                            
                            layer.farmId = farm.id;
                            layer.farmName = farm.farm_name;
                            layer.boundary = geoJsonFeature;  // Store the GeoJSON for intersection checking
                            
                            // Add popup with farm name
                            layer.bindPopup(`<strong>${farm.farm_name}</strong>`);
                            
                            // Add to existing farms layer group
                            existingFarms.addLayer(layer);
                        } catch (e) {
                            console.error("Error parsing farm boundary:", e);
                        }
                    });
                    
                    farmsListHtml += '</ul>';
                    
                    // Fit map to show all farms
                    if (existingFarms.getLayers().length > 0) {
                        map.fitBounds(existingFarms.getBounds(), { padding: [50, 50] });
                    }
                } else {
                    farmsListHtml = '<p>No farms added yet. Draw a boundary and submit the form to add your first farm.</p>';
                }
                
                document.getElementById("farmsList").innerHTML = farmsListHtml;
                
                // Add event listeners to zoom buttons
                document.querySelectorAll('.zoom-to-farm').forEach(button => {
                    button.addEventListener('click', function() {
                        const farmId = parseInt(this.getAttribute('data-farm-id'));
                        zoomToFarm(farmId);
                    });
                });
            })
            .catch(error => {
                console.error("Error fetching farms:", error);
                document.getElementById("farmsList").innerHTML = '<p class="text-danger">Error loading farms. Please try refreshing the page.</p>';
            });
        }
        
        // Function to zoom to a specific farm
        function zoomToFarm(farmId) {
            existingFarms.eachLayer(layer => {
                if (layer.farmId === farmId) {
                    map.fitBounds(layer.getBounds());
                    layer.openPopup();
                }
            });
        }
        
        // Try to get the user's location
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    var lat = position.coords.latitude;
                    var lng = position.coords.longitude;
    
                    // Set map view to user's location if no farms exist
                    if (existingFarms.getLayers().length === 0) {
                        map.setView([lat, lng], 14);
                    }
    
                    // Add marker at user's location
                    marker = L.marker([lat, lng]).addTo(map)
                        .bindPopup("Your Current Location").openPopup();
    
                    // Store lat/lng in hidden form fields if they exist
                    if (document.getElementById("latitude")) {
                        document.getElementById("latitude").value = lat;
                    }
                    if (document.getElementById("longitude")) {
                        document.getElementById("longitude").value = lng;
                    }
                },
                function(error) {
                    console.error("Geolocation error: " + error.message);
                }
            );
        } else {
            console.log("Geolocation is not supported by your browser.");
        }
    
        // Load Turf.js for polygon intersection checking
        var turfScript = document.createElement('script');
        turfScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js';
        document.head.appendChild(turfScript);
    
        // Create warning message element
        var warningContainer = document.createElement('div');
        warningContainer.id = 'intersection-warning';
        warningContainer.style.display = 'none';
        warningContainer.className = 'alert alert-danger mt-2';
        warningContainer.innerText = 'Warning: Farm boundary overlaps with an existing farm! Please redraw the boundary.';
        document.getElementById('map').parentNode.insertBefore(warningContainer, document.getElementById('map').nextSibling);
    
        var drawControl = new L.Control.Draw({
            edit: { featureGroup: drawnItems },
            draw: { 
                polygon: true,
                polyline: false,
                rectangle: true,
                circle: true,
                marker: false
            }
        });
        map.addControl(drawControl);
    
        // Function to check if polygons intersect
        function checkForIntersections(newPolygon) {
            // Make sure Turf.js is loaded
            if (typeof turf === 'undefined') {
                console.warn("Turf.js is not loaded yet. Skipping intersection check.");
                return false;
            }
    
            let hasIntersection = false;
            
            // Convert the new polygon to a Turf.js polygon
            let newTurfPolygon;
            try {
                newTurfPolygon = turf.polygon(newPolygon.coordinates);
            } catch (e) {
                console.error("Error converting new polygon to Turf.js format:", e);
                return false;
            }
    
            // Check against all existing farm boundaries
            existingFarms.eachLayer(existingLayer => {
                if (hasIntersection) return; // Skip if we already found an intersection
                
                if (existingLayer.boundary) {
                    try {
                        const existingTurfPolygon = turf.polygon(existingLayer.boundary.coordinates);
                        
                        // Check for intersection
                        const intersection = turf.booleanIntersects(newTurfPolygon, existingTurfPolygon);
                        
                        if (intersection) {
                            console.log(`Intersection detected with farm: ${existingLayer.farmName}`);
                            // Highlight the farm that intersects
                            existingLayer.setStyle({
                                color: 'red',
                                weight: 3,
                                fillOpacity: 0.4
                            });
                            existingLayer.openPopup();
                            hasIntersection = true;
                        } else {
                            // Reset style if previously highlighted
                            existingLayer.setStyle({
                                color: existingLayer.options.style.color,
                                weight: 2,
                                fillOpacity: 0.3
                            });
                        }
                    } catch (e) {
                        console.error("Error checking intersection:", e);
                    }
                }
            });
            
            return hasIntersection;
        }
    
        // Handle the drawn polygon
        map.on(L.Draw.Event.CREATED, function (event) {
            var layer = event.layer;
            
            // Convert to GeoJSON for validation
            let geoJSON = layer.toGeoJSON().geometry;
            
            // Check if this polygon intersects with any existing farms
            let intersects = checkForIntersections(geoJSON);
            
            if (intersects) {
                // Show warning
                document.getElementById('intersection-warning').style.display = 'block';
                
                // Add layer with red styling to indicate problem
                drawnItems.clearLayers();
                layer.setStyle({
                    color: 'red',
                    fillColor: '#ff6666',
                    fillOpacity: 0.4,
                    weight: 2
                });
                drawnItems.addLayer(layer);
                
                // Disable form submission
                document.getElementById('boundary').value = '';
                document.querySelector('#farmForm button[type="submit"]').disabled = true;
            } else {
                // Hide warning if previously shown
                document.getElementById('intersection-warning').style.display = 'none';
                
                // Add layer with normal styling
                drawnItems.clearLayers();
                drawnItems.addLayer(layer);
                
                // Store boundary and enable form submission
                document.getElementById('boundary').value = JSON.stringify(geoJSON);
                document.querySelector('#farmForm button[type="submit"]').disabled = false;
            }
        });
        
        // Clear warning when editing starts
        map.on(L.Draw.Event.DRAWSTART, function () {
            document.getElementById('intersection-warning').style.display = 'none';
        });

        const ownershipField = document.querySelector("#id_ownership");
        const leasedFieldsDiv = document.querySelector("#leasedFields");

        if (!ownershipField || !leasedFieldsDiv) {
            console.error("Ownership dropdown or leased fields div not found!");
            return;
        }

        function toggleLeasedFields() {
            if (ownershipField.value === "LEASED") {
                leasedFieldsDiv.style.display = "block";  // Show leased fields
            } else {
                leasedFieldsDiv.style.display = "none";  // Hide leased fields
            }
        }

        // Initialize on page load
        toggleLeasedFields();

    // Listen for changes in ownership dropdown
        ownershipField.addEventListener("change", toggleLeasedFields);
    });
    // AJAX Form Submission
    document.addEventListener("DOMContentLoaded", function () {
        const farmForm = document.getElementById("farmForm");
        const messageDiv = document.getElementById("message");
    
        // Function to handle form submission
        async function handleSubmit(event, action) {
            event.preventDefault();
    
            // Double-check that boundary exists
            if (!document.getElementById("boundary").value) {
                messageDiv.innerHTML = `
                    <div class="alert alert-danger">
                        Please draw a farm boundary on the map.
                    </div>
                `;
                return;
            }
    
            // Show loading message and hide the form
            farmForm.style.display = "none";
            messageDiv.innerHTML = `
                <div class="alert alert-info">
                    Uploading data, please wait...
                </div>
            `;
    
            try {
                // Gather form data
                const formData = new FormData(farmForm);
    
                // Send AJAX request with the farmer ID included in the URL
                const response = await fetch("{% url 'add_farm' farmer.id %}", {
                    method: "POST",
                    body: formData,
                    headers: { "X-Requested-With": "XMLHttpRequest" }
                });
    
                const data = await response.json();
    
                if (data.success) {
                    // Success message
                    messageDiv.innerHTML = `
                        <div class="alert alert-success mt-3">
                            <p>✅ Farm created successfully!</p>
                        </div>
                    `;
    
                    // Perform action based on the button clicked
                    if (action === "goNext") {
                        proceedToPlantation(data.farmer_id || {{ farmer.id }});
                    } else if (action === "addMore") {
                        // Reload the page to reflect the newly added farm
                        location.reload();
                    }
                } else {
                    // Display error message
                    messageDiv.innerHTML = `
                        <div class="alert alert-danger">
                            Error: ${data.errors || "Unknown error"}
                        </div>
                    `;
                    farmForm.style.display = "block"; // Re-enable the form
                }
            } catch (error) {
                console.error("Error:", error);
                messageDiv.innerHTML = `
                    <div class="alert alert-danger">
                        An unexpected error occurred. Please try again.
                    </div>
                `;
                farmForm.style.display = "block"; // Re-enable the form
            }
        }
    
        // Attach event listeners for both buttons
        document.getElementById("submitAndGoNext").addEventListener("click", function (event) {
            handleSubmit(event, "goNext");
        });
    
        document.getElementById("submitAndAddMore").addEventListener("click", function (event) {
            handleSubmit(event, "addMore");
        });
    
        // Function to proceed to plantation
        function proceedToPlantation(farmerId) {
            if (!farmerId) {
                alert("❌ Farmer ID missing! Cannot proceed to plantation.");
                return;
            }
            window.location.href = `/add-plantation/${farmerId}/`;
        }
    });
</script>

{% endblock %}